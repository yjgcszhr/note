# 第九章连贯性高级主题
在第7章和第8章中，我们在最简单的系统模型的背景下介绍了窥探和目录一致性协议，这些模型足以解释这些协议的基本问题。在本章中，我们将在几个方向上扩展我们对连贯性的介绍。在9.1节中，我们将讨论为更复杂的系统模型设计相干协议所涉及的问题。在第9.2节中，我们描述了适用于窥探和目录协议的优化。在9.3节中，我们将解释如何确保一致性协议保持活动状态(即避免死锁、活锁和饥饿)。在第9.4节中，我们介绍了令牌一致性协议[11]，这是最近开发的一类协议，包括窥探协议和目录协议。最后，我们将在第9.5节简要讨论相干性的未来。
## 9.1系统模型
到目前为止，我们假设了一个简单的系统模型，其中每个处理器核心都有一个物理寻址的单级回写数据缓存。这个系统模型省略了许多商业系统中通常存在的特性，比如指令缓存(第9.1.1节)、翻译旁置缓存(第9.1.2节)、虚拟寻址缓存(第9.1.3节)、透写缓存(第9.1.4节)、相干DMA(第9.1.5节)和多级缓存(第9.1.6节)。
### 9.1.1指令缓存
所有现代核心都至少有一级指令缓存，这就提出了是否以及如何支持指令缓存一致性的问题。虽然真正的自我修改代码很少见，但是当操作系统加载程序或库、JIT编译器生成代码或动态运行时系统重新优化程序时，包含指令的缓存块可能会被修改。在一致性协议中添加指令缓存表面上很简单;指令缓存中的块是只读的，因此要么处于稳定状态I，要么处于稳定状态s。此外，内核从不直接写指令缓存;核心通过对其数据缓存执行存储来修改代码。因此，指令缓存的一致性控制器只有在观察到GetM时才采取行动
