# 第九章连贯性高级主题
在第7章和第8章中，我们在最简单的系统模型的背景下介绍了窥探和目录一致性协议，这些模型足以解释这些协议的基本问题。在本章中，我们将在几个方向上扩展我们对连贯性的介绍。在9.1节中，我们将讨论为更复杂的系统模型设计相干协议所涉及的问题。在第9.2节中，我们描述了适用于窥探和目录协议的优化。在9.3节中，我们将解释如何确保一致性协议保持活动状态(即避免死锁、活锁和饥饿)。在第9.4节中，我们介绍了令牌一致性协议[11]，这是最近开发的一类协议，包括窥探协议和目录协议。最后，我们将在第9.5节简要讨论相干性的未来。
## 9.1系统模型
到目前为止，我们假设了一个简单的系统模型，其中每个处理器核心都有一个物理寻址的单级回写数据缓存。这个系统模型省略了许多商业系统中通常存在的特性，比如指令缓存(第9.1.1节)、翻译旁置缓存(第9.1.2节)、虚拟寻址缓存(第9.1.3节)、透写缓存(第9.1.4节)、相干DMA(第9.1.5节)和多级缓存(第9.1.6节)。
### 9.1.1指令缓存
所有现代核心都至少有一级指令缓存，这就提出了是否以及如何支持指令缓存一致性的问题。虽然真正的自我修改代码很少见，但是当操作系统加载程序或库、JIT编译器生成代码或动态运行时系统重新优化程序时，包含指令的缓存块可能会被修改。在一致性协议中添加指令缓存表面上很简单;指令缓存中的块是只读的，因此要么处于稳定状态I，要么处于稳定状态s。此外，内核从不直接写指令缓存;核心通过对其数据缓存执行存储来修改代码。因此，指令缓存的一致性控制器只有在观察到GetM时才采取行动从另一个缓存(可能是它自己的L1数据缓存)到状态S的块，并简单地使该块无效。指令缓存的一致性不同于数据缓存的一致性有几个原因。最重要的是，一旦被获取，一条指令可能会在内核的管道中缓冲许多个周期(例如，考虑一个核心，它的128条指令窗口充满了一个长序列的加载，每个加载都错过了到DRAM的所有路径)。修改代码的软件需要某种方法来知道写操作何时影响了获取的指令流。一些架构，如AMD Opteron，使用一个单独的结构来跟踪管道中的指令来解决这个问题。如果此结构检测到对运行中的指令的更改，则刷新管道。然而，由于指令的修改频率远低于数据，其他架构需要软件显式地管理一致性。例如，Power架构提供了icbi(指令缓存块无效)指令来使指令缓存项无效。
### 9.1.2 tlb (Translation Lookaside Buffers)
转换暂置缓冲区(tlb)是保存特殊类型数据的缓存:从虚拟地址到物理地址的转换。与其他缓存一样，它们必须保持一致。像指令缓存一样，它们在历史上没有参与处理数据缓存的相同的全硬件一致性协议。TLB一致性的传统方法是TLB击落[17]，这是一种软件管理的一致性方案，可能有也可能没有一些硬件支持。在一个经典的实现中，一个核心使一个转换项无效(例如，通过清除页表项的PageValid位)，并向所有核心发送一个处理器间中断。每个内核接收它的中断，向软件处理程序发送陷阱，或者使其tlb中的特定翻译项无效，或者刷新其tlb中的所有项(取决于平台)。每个核心也必须确保没有指令在飞行中使用现在陈旧的翻译，通常是通过冲洗管道。然后，每个内核使用处理器间中断将确认发送回初始内核。在修改翻译(或重用物理页面)之前，初始化核心等待所有的确认，确保所有过时的翻译条目都已无效。一些架构提供了加速TLB击落的特殊支持。例如，Power架构通过使用特殊的tlbie (TLB invalidate entry)指令消除了代价高昂的处理器间中断;初始化内核执行tlbie指令，该指令向所有内核广播无效的虚拟页码，并且仅在所有内核完成无效后才完成。最近的研究建议消除TLB击落，而是将TLB纳入现有的数据和指令缓存的全硬件一致性协议[15]。这种全硬件解决方案比TLB停机更具可伸缩性，但它需要对TLB进行修改，以使它们能够以与数据和指令缓存相同的方式进行寻址。也就是说，tlb必须窥探内存中保存翻译的块的物理地址。
