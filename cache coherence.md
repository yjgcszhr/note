# 一致性协议设计方法：
## 监听和 目录
## 决定核心写入块时要做什么：Invalidate protocol和Update protocol
![image](https://github.com/yjgcszhr/note/assets/45597060/0a3a0d88-1147-47b5-88be-1e6cd807b4f2)
## I到S(常见情况#1)

缓存控制器向目录发送一个get请求，并将块状态从I更改为ISD。该目录接收到这个请求，如果该目录是所有者(即，当前没有缓存包含M中的块)，则该目录用一个Data消息响应，将块的状态更改为S(如果它已经不是S)，并将请求者添加到共享者列表中。当数据到达请求者时
缓存控制器将块的状态更改为S，完成事务。
## I到S(常见情况#2)
缓存控制器向目录发送一个get请求，并将块状态从I更改为ISD。如果该目录不是所有者(即，当前有一个缓存包含M中的块)，则该目录将请求转发给所有者，并将块的状态更改为暂态SD。
所有者通过向请求者发送数据并将块的状态更改为s来响应此Fwd-GetS消息。现在以前的所有者也必须向目录发送数据，因为它正在将所有权交还给目录，该目录必须具有块的最新副本。当数据到达请求者时，缓存控制器将块状态更改为S，并考虑该数据块的状态
交易完成。当数据到达目录时，目录将其复制到内存中，将块状态更改为S，并认为事务完成。
## I到S(种族情况)
上面两个I-to-S场景代表了只有一个事务的常见情况
对于正在进行的块。协议的大部分复杂性来自于必须处理
一个块中多个正在进行的事务的不太常见的情况。例如，读取器可能会对缓存控制器接收到ISD状态块的Invalidation感到惊讶。考虑发出get并转到ISD的核心C1和发出GetM的另一个核心C2
块，该块在C1的get之后到达目录。目录首先发送C1 Data以响应其get，然后发送Invalidation以响应C2的GetM。由于Data和Invalidation在不同的网络上传输，它们可能会无序到达，因此C1可能会在Data之前接收Invalidation。
## I或S到M
缓存控制器向目录发送一个GetM请求，并将块的状态从I更改为
穆尼亚。在这种状态下，缓存等待Data和(可能的)inv - ack，这些inv - ack表明其他缓存已经使状态s中的块副本无效。缓存控制器知道预期会有多少inv - ack，因为Data消息包含AckCount，该AckCount可能为零。图8.3说明了响应GetM请求的目录的三种常见场景。如果目录处于状态I，它只是发送AckCount为0的Data并进入状态M
目录控制器将请求转发给所有者并更新块的所有者;现在以前的所有者通过发送AckCount为0的Data来响应Fwd-GetM请求。
最后一种常见情况发生在目录处于状态s时
一个AckCount等于共享者的数量，加上它向共享者列表中的每个核心发送Invalidations。接收Invalidation消息的缓存控制器使其共享副本无效，并向请求者发送invalidate - ack。当请求者接收到最后一个Inv-Ack时，它转换到状态M。
注意表8.1中特殊的Last-Inv-Ack事件，它简化了协议规范
这些常见的情况忽略了一些可能的竞争，这些竞争突出了目录协议的并发性。例如，核心C1的缓存块处于IMA状态，并从C2的缓存控制器接收Fwd-GetS。出现这种情况是可能的，因为目录已经向C1发送了Data，向共享器发送了Invalidation消息，并将其状态更改为m
目录，则该目录只是将其转发给所有者C1。这个转发请求可能在所有入侵请求到达C1之前到达C1。在这种情况下，我们的协议只是暂停，缓存控制器等待inv - ack。由于入侵报文在单独的网络上传输，因此可以保证它们不会阻塞在未处理的转发报文后面。
## 从M到I
为了驱逐处于状态M的块，缓存控制器发送一个包含数据的PutM请求，并将块状态更改为MIA。当目录接收到这个puttm时，它更新LLC/memory，使用Put-Ack进行响应，并转换到状态i。在请求者接收到Put-Ack之前，块的状态保持有效M，缓存控制器必须响应对块转发的一致性请求。在缓存控制器接收到转发相干的情况下
在发送PutM和接收Put-Ack之间，缓存控制器响应Fwd-GetS或Fwd-GetM，并将其块状态分别更改为SIA或IIA。这些暂态实际上分别是S和I，但表示缓存控制器必须等待Put-Ack来完成向I的转换。
## 从S到I
与前一章的窥探协议不同，我们的目录协议不会静默地驱逐状态为S的块。相反，为了替换状态为S的块，缓存控制器会发送一个PutS请求并将块状态更改为SIA。目录接收这个put，并以Put-Ack响应。在请求者接收到Put-Ack之前，块的状态是有效的s。如果缓存控制器在发送Put-Ack之后和接收Put-Ack之前接收到Invalidation请求，它将更改
块的状态到IIA。这个暂态状态实际上是I，但它表示缓存控制器必须等待Put-Ack来完成从S到I的事务
## 8.3添加独占状态
正如我们之前在窥探协议的上下文中所讨论的那样，添加Exclusive (E)状态是一个重要的优化，因为它使核心能够仅通过一个相干事务读取和写入块，而不是MSI协议所要求的两个相干事务。在最高级别上，这种优化与缓存一致性是使用窥探还是使用目录无关。如果一个内核发出了get请求，并且该块当前没有被其他内核共享，那么请求者可以获得状态为E的块，然后内核可以静默地将块的状态从E升级到M，而无需发出另一个一致性请求。在本节中，我们将E状态添加到基线MSI目录协议中。与前一章的MESI窥探协议一样，协议的操作取决于E状态是否被视为所有权状态。而且，与MESI窥探协议一样，主要的操作差异涉及确定哪个一致性控制器应该响应对目录提供给状态E的缓存的块的请求。自从目录将块提供给状态E的缓存以来，块可能已经从E默默地升级到M。在拥有E块的协议中，解决方案很简单。在E(或M)中包含块的缓存是所有者，因此必须响应请求。发送到目录的一致性请求将被转发到状态为E的块的缓存中，因为E状态是所有权状态，所以E块的删除不能静默执行;缓存必须向目录发出PutE请求。如果没有显式的PutE，目录将不知道该目录现在是所有者，并且应该响应传入的一致性请求。因为我们在本入门中假设E中的块是拥有的，所以这个简单的解决方案就是我们在本节的MESI协议中实现的。在不拥有E块的协议中，E块可以被静默地驱逐，但这会增加协议的复杂性。考虑这样一种情况:核心C1获得状态E的块，然后目录从核心C2接收GetS或GetM。目录知道C1要么i)仍然处于状态E, ii)处于状态M(如果C1执行了从E到M的静默升级)，要么iii)处于状态i(如果协议允许C1执行静默PutE)。如果C1在M中，则目录必须将请求转发给C1，以便C1可以提供最新版本的数据。如果C1在E中，则C1或目录可能会响应，因为它们都具有相同的数据。如果C1在I中，则目录必须响应。一个解决方案是让C1和目录都响应，我们将在第8.8.1节中对SGI Origin[10]的案例研究中详细描述。另一种解决方案是让目录将请求转发给C1。如果C1在I中，C1通知目录响应C2;否则，C1响应C2并通知目录它不需要响应C2。
## 8.4添加owned状态
出于同样的原因，我们在第7章中将Owned状态添加到基线MSI窥探协议中，架构师可能希望将Owned状态添加到第8.2节中介绍的基线MSI目录协议中。回顾第二章，如果一个缓存中有一个块处于Owned状态，那么这个块是有效的，只读的，脏的(也就是说，它最终必须更新内存)，并且是拥有的(也就是说，缓存必须响应块的一致性请求)。与MSI相比，添加Owned状态在三个重要方面改变了协议:(1)在M中观察Fwd-GetS的块的缓存将其状态更改为O，并且不需要(立即)将数据复制回LLC/内存，(2)缓存(在O状态下)比LLC/内存满足更多的一致性请求，(3)有更多的3跳事务(这将由MSI协议中的LLC/内存满足)。
## 8.4.1高级协议规范
我们在图8.7中指定了事务的高级视图，突出显示了与MSI协议的不同之处。最有趣的区别是，当处于状态I或S的块在所有者缓存中处于O状态，而在一个或多个共享器缓存中处于S状态时，请求者向目录发送GetM的事务。在这种情况下，目录将GetM转发给所有者，并追加AckCount。该目录还将Invalidations发送给每个共享器。所有者接收Fwd-GetM并使用Data和AckCount响应请求者。请求者使用这个接收到的AckCount来确定它何时收到了最后一个Inv-Ack。如果GetM的请求者是所有者(处于状态O)，则会有类似的事务。这里的不同之处在于，目录将AckCount直接发送给请求者，因为请求者是所有者。该协议有一个与PutM事务几乎相同的PutO事务。它包含数据的原因与PutM事务包含数据的原因相同，即，因为M和O都是脏状态。
## 8.5表示目录状态
在前面的章节中，我们假设了一个完整的目录，也就是说，该目录维护每个块的完整状态，包括(可能)具有共享副本的完整缓存集。然而，这个假设与目录协议的主要动机相矛盾:可伸缩性。在具有大量缓存的系统中(即，一个块的大量潜在共享者)，维护每个块的完整共享者集需要大量的存储空间，即使使用紧凑的位向量表示也是如此。对于具有少量缓存的系统，这可能是合理的目录一致性协议能够维护这个完整的集合，但是大型系统的架构师可能希望有更多可伸缩的解决方案来维护目录状态。有许多方法可以减少目录为每个块维护的状态量。这里我们讨论两种重要的技术:粗目录和有限指针。我们单独讨论这些技术，但注意到它们可以结合使用。我们将每个解决方案与基线设计进行对比，如图8.8顶部条目所示。
### 8.5.1粗目录
拥有完整的共享器集使目录能够将Invalidation消息准确地发送到那些处于状态s的块的缓存控制器。减少目录状态的一种方法是保守地维护一个粗略的共享器列表，该列表是实际共享器集的超集。也就是说，共享器列表中的一个给定条目对应于一组K个缓存，如图8.8中间的条目所示。如果该集合中的一个或多个缓存(可能)的块处于状态S，则设置共享器列表中的该位。GetM将导致目录控制器向该集合中的所有K个缓存发送Invalidation。因此，粗目录减少了目录状态，代价是不必要的Invalidation消息带来额外的互连网络带宽，以及处理这些额外的Invalidation消息所需的缓存控制器带宽。
